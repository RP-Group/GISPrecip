# -*- coding: utf-8 -*-
"""
/***************************************************************************
 GISPrecip
                                 A QGIS plugin
 Plugin that predicts the surface precipitation from GMI data.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2025-07-11
        git sha              : $Format:%H$
        copyright            : (C) 2025 by Gabriel Rocha Pinto
        email                : gabriel.rocha.pinto@outlook.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction, QFileDialog, QTableWidgetItem
from qgis.core import QgsProject, QgsRasterLayer

import numpy as np

from netCDF4 import Dataset

from sklearn.model_selection import train_test_split
from sklearn.svm import SVC
from sklearn.ensemble import RandomForestClassifier
from sklearn.tree import DecisionTreeClassifier
from sklearn.ensemble import AdaBoostClassifier
from sklearn.neural_network import MLPRegressor
from sklearn.preprocessing import StandardScaler
from sklearn.metrics import classification_report, confusion_matrix, mean_squared_error, mean_absolute_error
from scipy.stats import pearsonr
from imblearn.under_sampling import RandomUnderSampler

from scipy.interpolate import griddata

# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .GIS_Precip_dialog import GISPrecipDialog
import os.path
from pathlib import Path


class GISPrecip:
    """QGIS Plugin Implementation."""

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('GISPrecip', message)

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        self.iface = iface
        self.plugin_dir = os.path.dirname(__file__)
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'GISPrecip_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        self.actions = []
        self.menu = self.tr(u'&GISPrecip')
        self.first_start = None
        self.model = None
        self.dlg = None

    def add_action(
            self,
            icon_path,
            text,
            callback,
            enabled_flag=True,
            add_to_menu=True,
            add_to_toolbar=True,
            status_tip=None,
            whats_this=None,
            parent=None):

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToRasterMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        icon_path = ':/plugins/GIS_Precip/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'GIS Precip'),
            callback=self.run,
            parent=self.iface.mainWindow())

        self.first_start = True

    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginRasterMenu(
                self.tr(u'&GISPrecip'),
                action)
            self.iface.removeToolBarIcon(action)

    def get_layer_by_name(self, layer_name, idx=0):
        """Get a layer by its name."""
        layers = QgsProject.instance().mapLayersByName(layer_name)
        if layers:
            return layers[idx]
        else:
            return None

    def get_project_or_working_directory(self):
        """Get the project directory (if available) or working directory."""
        project = QgsProject.instance()
        project_filepath = project.fileName()
        if project_filepath:
            return os.path.dirname(project_filepath)
        else:
            return os.getcwd()

    def get_long_lat(self, layer):
        """Get longitude and latitude from the layer."""
        self.dlg.Log("Extracting longitude and latitude from layer: {}".format(layer.name()))
        crs = layer.crs()
        if crs.isGeographic():
            extent = layer.extent()
            long = np.linspace(extent.xMinimum(), extent.xMaximum(), layer.width())
            lat = np.linspace(extent.yMinimum(), extent.yMaximum(), layer.height())
            self.dlg.Log("Longitude and latitude extracted successfully.")
            return long, lat
        else:
            self.dlg.Log("Layer CRS is not geographic. Cannot extract longitude and latitude.")
            return None, None

    def get_gmi_data(self, gmi_layer):
        """Preprocess GMI data layer."""
        if not isinstance(gmi_layer, QgsRasterLayer):
            self.dlg.Log(
                f"ERROR: A camada selecionada '{gmi_layer.name()}' não é uma camada Raster. Por favor, selecione uma camada Raster válida.")
            return None, None, None

        self.dlg.Log("Preprocessing GMI data layer: {}".format(gmi_layer.name()))
        mask = True
        arr = gmi_layer.as_numpy(mask)
        long, lat = self.get_long_lat(gmi_layer)
        long_coords, lat_coords = np.meshgrid(lat, long, indexing='ij')
        long_flat = long_coords.flatten()
        lat_flat = lat_coords.flatten()
        data_flat = arr.reshape(gmi_layer.bandCount(), -1).T
        self.dlg.Log("GMI data preprocessing completed for layer: {}".format(gmi_layer.name()))
        return data_flat, long_flat, lat_flat

    def get_surf_precip_data(self, surf_precip_layer):
        """Preprocess surface precipitation data layer."""
        if not isinstance(surf_precip_layer, QgsRasterLayer):
            self.dlg.Log(
                f"ERROR: A camada selecionada '{surf_precip_layer.name()}' não é uma camada Raster. Por favor, selecione uma camada Raster válida.")
            return None, None, None

        self.dlg.Log("Preprocessing surface precipitation data layer: {}".format(surf_precip_layer.name()))
        mask = True
        arr = surf_precip_layer.as_numpy(mask)
        long, lat = self.get_long_lat(surf_precip_layer)
        long_coords, lat_coords = np.meshgrid(lat, long, indexing='ij')
        long_flat = long_coords.flatten()
        lat_flat = lat_coords.flatten()
        data_flat = arr.reshape(1, -1).T
        self.dlg.Log(
            "Surface precipitation data preprocessing completed for layer: {}".format(surf_precip_layer.name()))
        return data_flat, long_flat, lat_flat

    def preprocess_data_classifier(self, gmi_data, surf_precip_data, long, lat, model_name, normalize=True,
                                   under_sample=True):
        """Preprocess data for classification models."""
        if gmi_data.shape[0] != surf_precip_data.shape[0]:
            self.dlg.Log(f"ERRO: A dimensão dos dados de entrada não coincide. "
                         f"A camada GMI tem {gmi_data.shape[0]} pixels, enquanto a camada de Precipitação tem {surf_precip_data.shape[0]} pixels. "
                         f"Por favor, use camadas com as mesmas dimensões (largura e altura).")
            return None, None, None, None

        self.dlg.Log("Preprocessing data for classification...")
        mask = np.isfinite(gmi_data).all(axis=1) & np.isfinite(surf_precip_data).flatten()
        if np.ma.isMaskedArray(gmi_data):
            mask &= ~np.ma.getmaskarray(gmi_data).any(axis=1)
        if np.ma.isMaskedArray(surf_precip_data):
            mask &= ~np.ma.getmaskarray(surf_precip_data).flatten()
        gmi_data = gmi_data[mask]
        surf_precip_data = surf_precip_data[mask]
        long = long[mask]
        lat = lat[mask]

        # --- NEW: Conditional classification (Binary for SVM, Multiclass for others) ---
        if model_name == "SVM":
            self.dlg.Log("Criando classes binárias (Chuva/Não Chuva) para o modelo SVM.")
            surf_precip_data = (surf_precip_data > 0.1).astype(int)
        else:
            self.dlg.Log("Criando classes de intensidade de chuva (0: Nenhuma, 1: Leve, 2: Moderada, 3: Pesada).")
            y = surf_precip_data.flatten()
            cat = np.zeros_like(y, dtype=int)
            cat[(y > 0) & (y <= 5)] = 1  # Leve
            cat[(y > 5) & (y <= 15)] = 2  # Moderada
            cat[y > 15] = 3  # Pesada
            surf_precip_data = cat

        if under_sample:
            self.dlg.Log("Applying Random Under-sampling for class balancing...")
            gmi_data, surf_precip_data = RandomUnderSampler(random_state=42).fit_resample(gmi_data,
                                                                                          surf_precip_data.ravel())

        if normalize:
            scaler = StandardScaler()
            gmi_data = scaler.fit_transform(gmi_data)

        self.dlg.Log("Classification data preprocessing completed.")
        return gmi_data, surf_precip_data, long, lat

    def preprocess_data_regressor(self, gmi_data, surf_precip_data, long, lat, normalize=True):
        """Preprocess data for regression models."""
        if gmi_data.shape[0] != surf_precip_data.shape[0]:
            self.dlg.Log(f"ERRO: A dimensão dos dados de entrada não coincide. "
                         f"A camada GMI tem {gmi_data.shape[0]} pixels, enquanto a camada de Precipitação tem {surf_precip_data.shape[0]} pixels. "
                         f"Por favor, use camadas com as mesmas dimensões (largura e altura).")
            return None, None, None, None

        self.dlg.Log("Preprocessing data for regression...")
        mask = np.isfinite(gmi_data).all(axis=1) & np.isfinite(surf_precip_data).flatten()
        if np.ma.isMaskedArray(gmi_data):
            mask &= ~np.ma.getmaskarray(gmi_data).any(axis=1)
        if np.ma.isMaskedArray(surf_precip_data):
            mask &= ~np.ma.getmaskarray(surf_precip_data).flatten()
        gmi_data = gmi_data[mask]
        surf_precip_data = surf_precip_data[mask]
        long = long[mask]
        lat = lat[mask]

        if normalize:
            scaler = StandardScaler()
            gmi_data = scaler.fit_transform(gmi_data)

        self.dlg.Log("Regression data preprocessing completed.")
        return gmi_data, surf_precip_data, long, lat

    def preprocess_GMI_data(self, gmi_data, long, lat, normalize=True):
        """Preprocess the GMI data for prediction."""
        self.dlg.Log("Preprocessing GMI data for prediction...")
        mask = np.isfinite(gmi_data).all(axis=1)
        if np.ma.isMaskedArray(gmi_data):
            mask &= ~np.ma.getmaskarray(gmi_data).any(axis=1)
        gmi_data = gmi_data[mask]
        long = long[mask]
        lat = lat[mask]
        if normalize:
            scaler = StandardScaler()
            gmi_data = scaler.fit_transform(gmi_data)
        self.dlg.Log("Prediction data preprocessing completed.")
        return gmi_data, long, lat

    def get_model_metrics(self, y_true, y_pred):
        """Calculate model metrics."""
        self.dlg.Log("Calculating model metrics...")
        bias = np.mean(y_pred - y_true)
        mse = mean_squared_error(y_true, y_pred)
        mae = mean_absolute_error(y_true, y_pred)

        def smape(y_true, y_pred):
            denominator = np.abs(y_true) + np.abs(y_pred)
            return np.mean(2 * np.abs(y_pred - y_true) / (denominator + 1e-8))

        smape_value = smape(y_true, y_pred)
        if np.std(y_true) > 0 and np.std(y_pred) > 0:
            lin_corr = np.corrcoef(y_true, y_pred)[0, 1]
        else:
            lin_corr = np.nan
        self.dlg.Log("Model metrics calculated.")
        return bias, mse, mae, smape_value, lin_corr

    def export_to_netCDF4_file(self, width, height, long, lat, data, output_filepath):
        """Exports the prediction results to a NetCDF file."""
        output_dir = os.path.dirname(output_filepath)
        if not os.path.exists(output_dir):
            os.makedirs(output_dir)
        layer_name = Path(output_filepath).stem
        existing_layer = self.get_layer_by_name(layer_name)
        if existing_layer:
            QgsProject.instance().removeMapLayer(existing_layer.id())

        with Dataset(output_filepath, 'w', format='NETCDF4_CLASSIC') as ncfile:
            ncfile.createDimension('lon', width)
            ncfile.createDimension('lat', height)
            lon_var = ncfile.createVariable('lon', np.float32, ('lon',))
            lon_var.units = 'degrees'
            lon_var.long_name = 'Longitude'
            lat_var = ncfile.createVariable('lat', np.float32, ('lat',))
            lat_var.units = 'degrees'
            lat_var.long_name = 'Latitude'
            surf_precip = ncfile.createVariable('surface_precip', np.float32, ('lat', 'lon',))
            surf_precip.units = 'mm/h' if self.dlg.comboBox_InputModel.currentText() == "MLP Regressor" else "class"
            surf_precip.long_name = 'Surface Precipitation'

            grid_lon = np.linspace(min(long), max(long), width)
            grid_lat = np.linspace(min(lat), max(lat), height)
            X, Y = np.meshgrid(grid_lon, grid_lat)

            Z_nearest = griddata((long, lat), data, (X, Y), method='nearest')
            Z_linear = griddata((long, lat), data, (X, Y), method='linear')
            Z_nearest[np.isnan(Z_linear)] = np.nan

            lon_var[:] = grid_lon
            lat_var[:] = grid_lat
            surf_precip[:, :] = Z_nearest

        raster_layer = QgsRasterLayer(output_filepath, layer_name)
        raster_layer.setCrs(QgsProject.instance().crs())
        if not raster_layer.isValid():
            self.dlg.Log("Layer failed to load!")
        else:
            QgsProject.instance().addMapLayer(raster_layer)

    def train_model(self):
        """Dispatcher for training model based on user selection."""
        model_name = self.dlg.comboBox_InputModel.currentText()
        if model_name == "MLP Regressor":
            self.train_model_regressor()
        else:
            self.train_model_classifier()

    def test_model(self):
        """Dispatcher for testing model based on user selection."""
        model_name = self.dlg.comboBox_InputModel.currentText()
        if model_name == "MLP Regressor":
            self.test_model_regressor()
        else:
            self.test_model_classifier()

    def train_model_classifier(self):
        """Train a classification model."""
        self.dlg.Log("Training classification model...")
        checkedLayers_GMI = self.dlg.comboBox_InputGMI.checkedItems()
        selectedLayer_GMI = self.get_layer_by_name(checkedLayers_GMI[0])
        checkedLayers_SurfPrecip = self.dlg.comboBox_InputSurfPrecip.checkedItems()
        selectedLayer_SurfPrecip = self.get_layer_by_name(checkedLayers_SurfPrecip[0])

        bands, long, lat = self.get_gmi_data(selectedLayer_GMI)
        if bands is None: return

        surfPrecip, _, _ = self.get_surf_precip_data(selectedLayer_SurfPrecip)
        if surfPrecip is None: return

        model_name = self.dlg.comboBox_InputModel.currentText()
        processed_result = self.preprocess_data_classifier(bands, surfPrecip, long, lat, model_name,
                                                           normalize=True, under_sample=True)
        if processed_result[0] is None: return
        bands, surfPrecip, _, _ = processed_result

        if model_name == "SVM":
            self.model = SVC(kernel='rbf', C=100, gamma='scale', class_weight='balanced')
        elif model_name == "Random Forest":
            self.model = RandomForestClassifier(n_estimators=100, class_weight='balanced')
        elif model_name == "Decision Tree":
            self.model = DecisionTreeClassifier(class_weight='balanced')
        elif model_name == "AdaBoost":
            self.model = AdaBoostClassifier(n_estimators=100, random_state=42)

        self.model.fit(bands, surfPrecip.ravel())
        self.dlg.progressBar_TrainModel.setValue(100)
        self.dlg.Log("Classifier model training completed.")

    def train_model_regressor(self):
        """Train a regression model with optimized hyperparameters."""
        self.dlg.Log("Training regression model (MLP Regressor) with optimized parameters...")
        checkedLayers_GMI = self.dlg.comboBox_InputGMI.checkedItems()
        selectedLayer_GMI = self.get_layer_by_name(checkedLayers_GMI[0])
        checkedLayers_SurfPrecip = self.dlg.comboBox_InputSurfPrecip.checkedItems()
        selectedLayer_SurfPrecip = self.get_layer_by_name(checkedLayers_SurfPrecip[0])

        bands, long, lat = self.get_gmi_data(selectedLayer_GMI)
        if bands is None: return

        surfPrecip, _, _ = self.get_surf_precip_data(selectedLayer_SurfPrecip)
        if surfPrecip is None: return

        processed_result = self.preprocess_data_regressor(bands, surfPrecip, long, lat, normalize=True)
        if processed_result[0] is None: return
        bands, surfPrecip, _, _ = processed_result

        self.model = MLPRegressor(
            hidden_layer_sizes=(249, 413, 402, 170),
            activation='relu',
            alpha=0.0011045192633616075,
            learning_rate_init=0.001176882824072647,
            max_iter=500,
            random_state=42
        )

        self.model.fit(bands, surfPrecip.ravel())

        self.dlg.progressBar_TrainModel.setValue(100)
        self.dlg.Log("Regressor model training completed.")

    def test_model_classifier(self):
        """Test the classification model."""
        self.dlg.Log("Testing classification model...")
        checkedLayers_GMI = self.dlg.comboBox_TestGMI.checkedItems()
        selectedLayer_GMI = self.get_layer_by_name(checkedLayers_GMI[0])
        checkedLayers_SurfPrecip = self.dlg.comboBox_TestSurfPrecip.checkedItems()
        selectedLayer_SurfPrecip = self.get_layer_by_name(checkedLayers_SurfPrecip[0])

        bands, long, lat = self.get_gmi_data(selectedLayer_GMI)
        if bands is None: return

        surfPrecip, _, _ = self.get_surf_precip_data(selectedLayer_SurfPrecip)
        if surfPrecip is None: return

        model_name = self.dlg.comboBox_InputModel.currentText()
        processed_result = self.preprocess_data_classifier(bands, surfPrecip, long, lat, model_name,
                                                           normalize=True, under_sample=False)
        if processed_result[0] is None: return
        bands, surfPrecip, valid_long, valid_lat = processed_result

        y_pred = self.model.predict(bands)
        self.dlg.Log("Model evaluation:")
        self.dlg.Log(classification_report(surfPrecip, y_pred, zero_division=0))
        self.dlg.Log("Confusion Matrix:")
        self.dlg.Log(str(confusion_matrix(surfPrecip, y_pred)))

        # --- NEW: Clear regression metrics for classifiers ---
        self.dlg.Log("Métricas de regressão (Bias, MSE, etc.) não são aplicáveis para modelos de classificação.")
        for i in range(self.dlg.tableWidget_ModelMetrics.columnCount()):
            self.dlg.tableWidget_ModelMetrics.setItem(0, i, QTableWidgetItem(""))

        long_width, lat_height = self.get_long_lat(selectedLayer_GMI)
        filepath = self.dlg.fileWidget_TestOutput.lineEdit().value()
        if not filepath:
            filepath = os.path.join(self.get_project_or_working_directory(), 'Output', 'test_output_classifier.nc')
        self.export_to_netCDF4_file(len(long_width), len(lat_height), valid_long, valid_lat, y_pred, filepath)

        self.dlg.progressBar_RunTest.setValue(100)
        self.dlg.Log("Classifier model testing completed.")

    def test_model_regressor(self):
        """Test the regression model."""
        self.dlg.Log("Testing regression model (MLP Regressor)...")
        checkedLayers_GMI = self.dlg.comboBox_TestGMI.checkedItems()
        selectedLayer_GMI = self.get_layer_by_name(checkedLayers_GMI[0])
        checkedLayers_SurfPrecip = self.dlg.comboBox_TestSurfPrecip.checkedItems()
        selectedLayer_SurfPrecip = self.get_layer_by_name(checkedLayers_SurfPrecip[0])

        bands, long, lat = self.get_gmi_data(selectedLayer_GMI)
        if bands is None: return

        surfPrecip, _, _ = self.get_surf_precip_data(selectedLayer_SurfPrecip)
        if surfPrecip is None: return

        processed_result = self.preprocess_data_regressor(bands, surfPrecip, long, lat, normalize=True)
        if processed_result[0] is None: return
        bands, surfPrecip, valid_long, valid_lat = processed_result

        y_pred = self.model.predict(bands)
        self.dlg.Log("Model evaluation (Metrics):")

        long_width, lat_height = self.get_long_lat(selectedLayer_GMI)
        filepath = self.dlg.fileWidget_TestOutput.lineEdit().value()
        if not filepath:
            filepath = os.path.join(self.get_project_or_working_directory(), 'Output', 'test_output_regressor.nc')
        self.export_to_netCDF4_file(len(long_width), len(lat_height), valid_long, valid_lat, y_pred, filepath)

        y_true = surfPrecip.flatten()
        bias, mse, mae, smape_value, lin_corr = self.get_model_metrics(y_true, y_pred)
        self.dlg.Log(
            f"Bias: {bias:.4f}, MSE: {mse:.4f}, MAE: {mae:.4f}, SMAPE: {smape_value:.4f}, Corr: {lin_corr:.4f}")

        self.dlg.tableWidget_ModelMetrics.setItem(0, 0, QTableWidgetItem(f"{bias:.4f}"))
        self.dlg.tableWidget_ModelMetrics.setItem(0, 1, QTableWidgetItem(f"{mse:.4f}"))
        self.dlg.tableWidget_ModelMetrics.setItem(0, 2, QTableWidgetItem(f"{mae:.4f}"))
        self.dlg.tableWidget_ModelMetrics.setItem(0, 3, QTableWidgetItem(f"{smape_value:.4f}"))
        self.dlg.tableWidget_ModelMetrics.setItem(0, 4, QTableWidgetItem(f"{lin_corr:.4f}"))

        self.dlg.progressBar_RunTest.setValue(100)
        self.dlg.Log("Regressor model testing completed.")

    def predict_model(self):
        """Predict surface precipitation with the trained model."""
        self.dlg.Log("Predicting model with selected GMI data...")
        if not self.model:
            self.dlg.Log("Error: Model is not trained. Please train a model first.")
            return

        checkedLayers_GMI = self.dlg.comboBox_ForecastGMI.checkedItems()
        selectedLayer_GMI = self.get_layer_by_name(checkedLayers_GMI[0])

        bands, long, lat = self.get_gmi_data(selectedLayer_GMI)
        if bands is None: return

        bands, valid_long, valid_lat = self.preprocess_GMI_data(bands, long, lat, normalize=True)

        y_pred = self.model.predict(bands)

        long_width, lat_height = self.get_long_lat(selectedLayer_GMI)
        filepath = self.dlg.fileWidget_ForecastOutput.lineEdit().value()
        if not filepath:
            filepath = os.path.join(self.get_project_or_working_directory(), 'Output', 'forecast_output.nc')
        self.export_to_netCDF4_file(len(long_width), len(lat_height), valid_long, valid_lat, y_pred, filepath)

        self.dlg.progressBar_Predict.setValue(100)
        self.dlg.Log("Model prediction completed.")

    def run(self):
        """Run method that performs all the real work"""
        if self.first_start:
            self.first_start = False
            self.dlg = GISPrecipDialog()
            self.dlg.button_TrainModel.clicked.connect(self.train_model)
            self.dlg.button_RunTest.clicked.connect(self.test_model)
            self.dlg.button_Predict.clicked.connect(self.predict_model)

        self.dlg.Log("Plugin initialized.")

        try:
            os.chdir(os.path.dirname(os.path.abspath(__file__)))
            self.dlg.Log(f"Current directory: {os.getcwd()}")
        except Exception as e:
            self.dlg.Log(f"Could not change directory: {e}")

        layers = QgsProject.instance().mapLayers().values()
        raster_layers = [layer.name() for layer in layers if isinstance(layer, QgsRasterLayer)]

        self.dlg.comboBox_InputGMI.clear()
        self.dlg.comboBox_InputSurfPrecip.clear()
        self.dlg.comboBox_TestGMI.clear()
        self.dlg.comboBox_TestSurfPrecip.clear()
        self.dlg.comboBox_ForecastGMI.clear()

        self.dlg.comboBox_InputGMI.addItems(raster_layers)
        self.dlg.comboBox_TestGMI.addItems(raster_layers)
        self.dlg.comboBox_InputSurfPrecip.addItems(raster_layers)
        self.dlg.comboBox_TestSurfPrecip.addItems(raster_layers)
        self.dlg.comboBox_ForecastGMI.addItems(raster_layers)

        self.dlg.comboBox_InputModel.clear()
        self.dlg.comboBox_InputModel.addItems(["SVM", "Random Forest", "Decision Tree", "AdaBoost", "MLP Regressor"])

        directory = self.get_project_or_working_directory()
        output_dir = os.path.join(directory, 'Output')
        self.dlg.fileWidget_TestOutput.lineEdit().setValue(os.path.join(output_dir, 'test_output.nc'))
        self.dlg.fileWidget_ErrorOutput.lineEdit().setValue(os.path.join(output_dir, 'error_output.nc'))
        self.dlg.fileWidget_ForecastOutput.lineEdit().setValue(os.path.join(output_dir, 'forecast_output.nc'))

        self.dlg.show()
        result = self.dlg.exec_()
        if result:
            pass